paste(a, collapse = ',')
a = c('ass','bb')
paste(a, collapse = ',')
print(paste(a, collapse = ' '))
print(paste(a, collapse = ''))
library(ggplot2)
x <- c('a','a','b','c')
qplot(x)
qplot(data = mpg, x = hwy)
qplot(data = mpg, x = cty)
qplot(data = mpg, x = drv)
qplot(data = mpg, x = drv, y = hwy)
qplot(data = mpg, x = hwy, geom = "line")
qplot(data = mpg, x = drv, y = hwy, geom = "line")
qplot(data = mpg, x = drv, y = hwy, geom = "boxplot")
qplot(data = mpg, x = drv, y = hwy, geom = "boxplot", color = drv)
df_midterm = data.frame(eng, math, class)
## dataframe
eng = c(5, 10, 30, 20)
math = c(23, 20, 14, 23)
class = c(1,1,2,2)
df_midterm = data.frame(eng, math, class); df_midterm
mean(df_midterm)
mean(df_midterm$eng)
library(ggplot2)
# box plot
fig(4,4)
bp <- ggplot(data = mpg, aes(x = drv, y = hwy)) + geom_boxplot()
bp + scale_fill_manual(values = c("skyblue",'royalblue','blue'))
library(ggplot2)
library(dplyr)
library(tidyr)
library(cowplot)
library(agricolae)
library(kableExtra)
# setting
install.packages("ggplot2")
install.packages("dplyr") # pipeline
install.packages("tidyr") # gather
install.packages("cowplot")
install.packages("agricolae")
install.packages("kableExtra")
install.packages("xml2")
library(ggplot2)
library(dplyr)
library(tidyr)
library(cowplot)
library(agricolae)
library(kableExtra)
### 1. 집단 자료 비교하기
### 1.1 두 모집단의 비교
line1 <- c(16.9, 16.4, 17.2, 16.4, 16.5, 17.0, 17.0, 17.2, 16.6, 16.6)
line2 <- c(16.6, 16.8, 17.4, 17.1, 17.0, 16.9, 17.3, 17.0, 17.1, 17.3)
df220 <- data.frame(line1, line2)
df220
# 넓은 형태의 자료를 좁은 형태로 바꾸기
df22<- gather(df220,  key="line", value="strength")
df22
# 기술통계량에 의한 자료요약
summary(df220)
df22 %>%
group_by(line) %>%
summarise(mean=mean(strength),
median= median(strength),
sd=sd(strength),
min=min(strength),
max=max(strength))
# 그룹데이터 시각화
with(df22, boxplot(strength~line)) # with : 어떤 데이터셋에 대해 간편히 접근
ggplot(df22, aes(line, strength)) +  geom_boxplot()
## 1.2 세 개 이상의 모집단의 비교
company<- as.factor(rep(c(1:4), each=4))
response<- c(1.93, 2.38, 2.20, 2.25,
2.55, 2.72, 2.75, 2.70,
2.40, 2.68, 2.32, 2.28,
2.33, 2.38, 2.28, 2.25)
df31<- data.frame(company=company, response= response)
df31
# 기술통계량
df31s <- df31 %>% group_by(company) %>%  summarise(mean=mean(response), median= median(response), sd=sd(response), min=min(response), max=max(response))
df31s
# 시각화
with(df31, boxplot(response~company))
ggplot(df31, aes(company, response)) +  geom_boxplot()
# 박스플롯 선으로 잇기
ggplot(df31, aes(company, response)) +
geom_boxplot() +
geom_line(data=df31s, aes(x=company, y=mean, group=1), size=1.5, col="#9ACBF9") +
geom_point(data=df31s, aes(x=company, y=mean), col="darkblue", size=3) +
theme_bw()
### 2. 두집단의 평균비교
t.test(strength~line, df22, paired = FALSE, var.equal = TRUE, conf.level = 0.95)
### 3. 일원배치법
# 시각화
ggplot(df31, aes(company, response)) +
geom_point(aes(colour = factor(company)), size = 2)
### 4. ANOVA F-test와 사후 추정
# ANOVA table
anova.res <- aov(response ~ company, data = df31)
summary(anova.res)
# 사후 추정 (LSD.test 함수 from agricolae package)
result1 = LSD.test(anova.res, "company", group = F, console = T)
result2 <- LSD.test(anova.res, "company", group=T, console = T)
plot(result2)
library(ggplot2)
library(dplyr)
library(tidyr)
library(cowplot)
library(agricolae)
library(kableExtra)
### 1. 집단 자료 비교하기
### 1.1 두 모집단의 비교
line1 <- c(16.9, 16.4, 17.2, 16.4, 16.5, 17.0, 17.0, 17.2, 16.6, 16.6)
line2 <- c(16.6, 16.8, 17.4, 17.1, 17.0, 16.9, 17.3, 17.0, 17.1, 17.3)
df220 <- data.frame(line1, line2)
df220
# 넓은 형태의 자료를 좁은 형태로 바꾸기
df22<- gather(df220,  key="line", value="strength")
df22
# 기술통계량에 의한 자료요약
summary(df220)
df22 %>%
group_by(line) %>%
summarise(mean=mean(strength),
median= median(strength),
sd=sd(strength),
min=min(strength),
max=max(strength))
# 그룹데이터 시각화
with(df22, boxplot(strength~line)) # with : 어떤 데이터셋에 대해 간편히 접근
ggplot(df22, aes(line, strength)) +  geom_boxplot()
## 1.2 세 개 이상의 모집단의 비교
company<- as.factor(rep(c(1:4), each=4))
response<- c(1.93, 2.38, 2.20, 2.25,
2.55, 2.72, 2.75, 2.70,
2.40, 2.68, 2.32, 2.28,
2.33, 2.38, 2.28, 2.25)
df31<- data.frame(company=company, response= response)
df31
# 기술통계량
df31s <- df31 %>% group_by(company) %>%  summarise(mean=mean(response), median= median(response), sd=sd(response), min=min(response), max=max(response))
df31s
# 시각화
with(df31, boxplot(response~company))
ggplot(df31, aes(company, response)) +  geom_boxplot()
# 박스플롯 선으로 잇기
ggplot(df31, aes(company, response)) +
geom_boxplot() +
geom_line(data=df31s, aes(x=company, y=mean, group=1), size=1.5, col="#9ACBF9") +
geom_point(data=df31s, aes(x=company, y=mean), col="darkblue", size=3) +
theme_bw()
### 2. 두집단의 평균비교
t.test(strength~line, df22, paired = FALSE, var.equal = TRUE, conf.level = 0.95)
### 3. 일원배치법
# 시각화
ggplot(df31, aes(company, response)) +
geom_point(aes(colour = factor(company)), size = 2)
### 4. ANOVA F-test와 사후 추정
# ANOVA table
anova.res <- aov(response ~ company, data = df31)
summary(anova.res)
# 사후 추정 (LSD.test 함수 from agricolae package)
result1 = LSD.test(anova.res, "company", group = F, console = T)
result2 <- LSD.test(anova.res, "company", group=T, console = T)
plot(result2)
#------------------------------------------------------------------
## 4. religion & divorce
table(religion)
#------------------------------------------------------------------
## 4. religion & divorce
table(welfare$religion)
library(foreign)
library(dplyr)
library(ggplot2)
library(readxl)
#------------------------------------------- setting
setwd("C:/Users/user/study/R_BasicSkills/sample_data")
raw_welfare = read.spss(file = "Koweps_hpc10_2015_beta1.sav",
to.data.frame = T)
welfare = raw_welfare
welfare = rename(welfare,
sex = h10_g3,
birth = h10_g4,
marriage = h10_g10,
religion = h10_g11,
income = p1002_8aq1,
code_job = h10_eco9,
code_region = h10_reg7)
welfare$sex <- ifelse(welfare$sex == 1, "male", "female")
table(welfare$sex)
qplot(welfare$sex)
# missing value handling
# income의 정상값 범위는 1 ~ 9998
# 소득변수에 대한 분석을 위해서는 결측값을 모두 제거해야함
welfare$income = ifelse(welfare$income == 0, NA, welfare$income)
# create age variable
welfare$age = 2015 - welfare$birth + 1
list_job = read_excel("Koweps_Codebook.xlsx", col_names = T, sheet = 2)
# code로된 변수를 쉽게 인식하기위한 join
welfare = left_join(welfare, list_job, id = "code_job")
install.packages("gridExtra")
library(gridExtra)
table(welfare$religion)
# change coding
welfare$religion = ifelse(welfare$religion == 1, "yes", "no")
table(welfare$religion)
table(welfare$marriage)
qplot(welfare$group_marriage)
# create divorce variable
welfare$group_marriage = ifelse(welfare$marriage == 1, "marriage",
ifelse(welfare$marriage == 3, "divorce",NA))
qplot(welfare$group_marriage)
marriage_divorce = welfare %>%
filter(!is.na(group_marriage)) %>%
group_by(religion ,group_marriage) %>%
summarise(n = n())
marriage_divorce
marriage_divorce = welfare %>%
filter(!is.na(group_marriage)) %>%
group_by(religion ,group_marriage) %>%
summarise(n = n()) %>%
mutate(tot_group = sum(n)) %>%
mutate(pct = round(n/tot_group * 100, 1))
marriage_divorce
# refine
welfare %>%
filter(!is.na(group_marriage)) %>%
group_by(religion) %>%
summarise(n = n())
divorce = religion_divorce %>%
filter(group_marriage == "divorce") %>%
select(religion, pct)
religion_divorce = welfare %>%
filter(!is.na(group_marriage)) %>%
group_by(religion ,group_marriage) %>%
summarise(n = n()) %>%
mutate(tot_group = sum(n)) %>%
mutate(pct = round(n/tot_group * 100, 1))
religion_divorce
# divorce
divorce = religion_divorce %>%
filter(group_marriage == "divorce") %>%
select(religion, pct)
divorce
ggplot(data = divorce, aex(x = religion, y = pct, fill = religion)) +
geom_bar
ggplot(data = divorce, aes(x = religion, y = pct, fill = religion)) +
geom_bar
ggplot(data = divorce, aes(x = religion, y = pct, fill = religion)) +
geom_bar()
ggplot(data = divorce, aes(x = religion, y = pct, fill = religion)) +
geom_col()
# statistical inference
testing_set = welfare %>%
filter(!is.na(group_marriage)) %>%
select(religion, group_marriage)
testing_set
g1 = testing_set %>% filter(religion = "yes")
g2 = testing_set %>% filter(religion = "no")
g1 = testing_set %>% filter(religion == "yes")
g2 = testing_set %>% filter(religion == "no")
g1
g1 = testing_set %>% filter(religion == "yes") %>% select(divorce)
g2 = testing_set %>% filter(religion == "no") %>% select(divorce)
g1 = testing_set %>% filter(religion == "yes") %>% select(group_marriage)
g2 = testing_set %>% filter(religion == "no") %>% select(group_marriage)
g1
g1 = ifelse(g1$group_marriage == "marriage", 1, 0)
g2 = ifelse(g2$group_marriage == "marriage", 1, 0)
g1
t.test(g1, g2)
var(g1)
var(g2)
mean(g1)
mean(g2)
n(g1)
length(g1)
length(g2)
sd(g1)
sd(g2)
print(mean(g1) / sd(g1))
print(mean(g2) / sd(g2))
print(length(g1));print(length(g2))
t.test(g1, g2)
library(stat)
install.packages("stat")
install.packages("STAT")
# 것보다 비율 검정을 따로 하는게 더 정확하지 않겠음?
prop.test(c(sum(g1), sum(g2)), c(length(g1), length(g2)))
mean(g1)
#------------------------------------------------------------------
## 5. region & age
class(welfare$code_region)
table(welfare$code_region)
list_region = data.frame(code_region = c(1:7),
region = c("서울",
"수도권(인천/경기)",
"부산/경남/울산",
"대구/경북",
"대전/충남",
"강원/충북",
"광주/전남/전북/제주도"))
welfare = left_join(welfare, list_region, id = "code_region")
welfare %>%
select(code_region, region) %>%
head
meanage_for_region = welfare %>%
group_by(region) %>%
summarise(mean_age = mean(age))
meanage_for_region
ggplot(data = meanage_for_region, aes(x = region, y = mean_age)) + geom_col()
ggplot(data = meanage_for_region, aes(x = region, y = mean_age)) +
geom_col() +
coord_flip()
ggplot(data = meanage_for_region, aes(x = reorder(region, mean_age), y = mean_age)) +
geom_col() +
coord_flip()
ggplot(data = meanage_for_region, aes(x = reorder(region, mean_age),
y = mean_age,
fill = region)) +
geom_col() +
coord_flip()
welfare = welfare %>% mutate(ageg = ifelse(age < 30, "young",
ifelse(age < 60, "middle","old")))
welfare$ageg
# 지역별 연령대 범주 소속 관측총합
region_ageg = welfare %>%
group_by(region, ageg) %>%
summarise(n = n()) %>%
mutate(tot_group = sum(n)) %>%
mutate(pct = round(n / tot_group * 100, 2)) %>%
head
# 지역별 연령대 범주 소속 관측총합
region_ageg = welfare %>%
group_by(region, ageg) %>%
summarise(n = n()) %>%
mutate(tot_group = sum(n)) %>%
mutate(pct = round(n / tot_group * 100, 2)) %>%
head()
region_ageg = welfare %>%
group_by(region, ageg) %>%
summarise(n = n()) %>%
mutate(tot_group = sum(n)) %>%
mutate(pct = round(n / tot_group * 100, 2))
region_ageg
ggplot(data = region_ageg, aes(x = region, y = pct, fill = ageg)) +
geom_col() +
coord_flip()
region_ageg
order = order_ageg$region
order_ageg = region_ageg %>%
filter(ageg == "old") %>%
arrange(pct)
order = order_ageg$region
order
order_ageg
ggplot(data = region_ageg, aes(x = region, y = pct, fill = ageg)) +
geom_col() +
coord_flip() +
scale_x_discrete(limits = order)
ggplot(data = region_ageg, aes(x = region, y = pct, fill = ageg)) +
geom_col() +
# coord_flip() +
scale_x_discrete(limits = order)
# young - middle - old 순으로 출력하고자 함
region_ageg$ageg = factor(region_ageg$ageg,
level = c("old", "middle",'young'))
class(region_ageg$ageg)
levels(region_ageg$ageg)
ggplot(data = region_ageg, aes(x = region, y = pct, fill = ageg)) +
geom_col() +
coord_flip() +
scale_x_discrete(limits = order)
